# -*- coding: utf-8 -*-
"""model-viz.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mIw6QLoRhCzKzlkqEMw8EygG4gLiNRtP
"""
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor

import argparse


parser = argparse.ArgumentParser()
parser.add_argument('--chunk', dest='chunk', type=int, help='Device and Chunk ID')
args = parser.parse_args()

print ('Attempting to use CUDA GPU ', args.chunk)
chunk = args.chunk


from torchvision import models
from PIL import Image
import torch.nn as  nn
import torch
device = torch.device(f"cuda:{chunk}" if torch.cuda.is_available() else "cpu")
import torchvision.transforms as standard_transforms
import os
import base64
import io
import pandas as pd
import altair as alt
from altair_saver import save
import numpy

labelNames = ['3D objects',
    'Algorithm',
    'Area chart',
    'Bar plots',
    'Block diagram',
    'Box plot',
    'Bubble Chart',
    'Confusion matrix',
    'Contour plot',
    'Flow chart',
    'Geographic map',
    'Line Chart',
    'Heat map',
    'Histogram',
    'Mask',
    'Medical images',
    'Natural images',
    'Pareto charts',
    'Pie chart',
    'Polar plot',
    'Radar chart',
    'Scatter plot',
    'Sketches',
    'Surface plot',
    'Tables',
    'Tree Diagram',
    'Vector plot',
    'Venn Diagram']

def fig_classification(fig_class_model_path):
    fig_model =  models.resnext101_32x8d()
    print('created model')
    num_features = fig_model.fc.in_features
    print('got num features')
    fc = list(fig_model.fc.children()) # Remove last layer
    print('removes last layer')
    fc.extend([nn.Linear(num_features, 28)]) # Add our layer with 4 outputs
    print('added our layer')
    fig_model.fc = nn.Sequential(*fc)
    print('modified model')
    fig_model = fig_model.to(device)
    print('moved model to device')
    fig_model.load_state_dict(torch.load(fig_class_model_path, map_location=device))
    print('loded state')
    fig_model.eval()
    mean_std = ( [.485, .456, .406], [.229, .224, .225])
    fig_class_trasform = standard_transforms.Compose([
        standard_transforms.Resize((384, 384), interpolation=Image.ANTIALIAS),
        standard_transforms.ToTensor(),
        standard_transforms.Normalize(*mean_std)         ])
    return fig_model, fig_class_trasform


def divide_chunks(l, n):
    segments = []
    for i in range(0, len(l), n):
        segments.append(l[i:i+n])
    return segments

# model weight, file 'epoch_9_loss_0.04706_testAcc_0.96867_X_resnext101_docSeg.pth' needs to be uploaded before run
fig_model, fig_class_trasform = fig_classification('model/epoch_9_loss_0.04706_testAcc_0.96867_X_resnext101_docSeg.pth')

image_dir = 'data-100k/base64Images/' # change path to a directory where you keep inputs
image_paths = os.listdir(image_dir)
image_paths = [os.path.join(image_dir, p) for p in image_paths]

image_paths.sort()

# Check if there are any existing files
# pending_df = pd.read_csv('pending_files.csv')
# pending_files = pending_df['Filename'].tolist()

# image_paths = pending_files
# image_paths.sort()

print(f'Fetching information from {len(image_paths)}')

# image_paths = divide_chunks(image_paths, 22000)
# image_paths = image_paths[chunk]

classifications = []
failed = []

def classify(img_path):
    print(f'Processing Image: {img_path}')
    try:
        with open(img_path, 'r') as f:
            base64image = f.read()
        base64decoded = base64.b64decode(base64image)
        image = Image.open(io.BytesIO(base64decoded)).convert('RGB')
        img_tensor = fig_class_trasform(image)
        if torch.cuda.is_available():
            fig_label = fig_model(img_tensor.cuda().unsqueeze(0))
        else:
            fig_label = fig_model(img_tensor.unsqueeze(0))
        fig_prediction = fig_label.max(1)[1]
        classification = (img_path, labelNames[fig_prediction])
        print(classification, img_path, fig_prediction)
        return classification, None
    except Exception as e:
        print('Failed with exception: ', e)
        return None, img_path


with ThreadPoolExecutor(max_workers=2) as executor:
    for classification, fail in executor.map(classify, image_paths):
        classifications.append(classification)
        failed.append(fail)

print(len(classifications))
print(len(failed))

df = pd.DataFrame([[n[0], n[0].split('.ipynb')[0], n[1]] for n in classifications if n is not None], columns=['Name', 'NotebookName', 'Category'])

# print(classifications[:10][0][0])

print(df)
df.to_csv(f'model-results-{chunk}.csv', header=True, index=False)

"""### Summary of distributions of number of plots"""

dup = df.groupby('NotebookName').agg('nunique').reset_index(drop=False).sort_values('Category', ascending=False)
print(dup)

arr = dup['Name'].to_numpy()
print(arr)

def CDF(arr):
    n = len(arr)
    arr = numpy.sort(arr)
    y = numpy.arange(1, n + 1) / n  # calculate cumulative probability
    return arr, y

x, y = CDF(arr)
cdf = [{"freq": _x, "dens": _y} for _x, _y in zip(x, y)]
df_cdf = pd.DataFrame.from_records(cdf)
print(df_cdf)

cdf_chart = alt.Chart(df_cdf).mark_line().encode(
    y=alt.Y('dens:Q', title="Percentile"),
    x=alt.X("freq:Q", title="# images in each notebook")
).properties(
    title="CDF of the Number of Figures per Notebooks",
    height=500, 
    width=700
)
cdf_chart.save(f'model/summary-100k/generated-cdf-{chunk}.html')

"""### Visualization for counts of different category

Name = the unique id for each plot
NotebookName = which notebook does the plot comes from
Categoty = the type of chart
"""

# group by, 'Category' the type of chart to get the number of (1) images in each category as 'Name' (2) notebook that contains the type of chart
cat = df.groupby('Category').agg('nunique').reset_index(drop=False).sort_values('Name', ascending=False)
print(cat)

print(df)

bars = alt.Chart(cat).mark_bar().encode(
    y=alt.Y('Category:N', sort='-x', title="Type of Charts"),
    x=alt.X("Name:Q", title="Counts")
)

text = bars.mark_text(
    align='left',
    baseline='middle',
    dx=3  # Nudges text to right so it doesn't appear on top of the bar
).encode(
    text='Name:Q'
).properties(
    title="Type of charts and its counts in 1K Notebooks"
)

chart = (bars + text).properties(height=1000, width=700)
chart.save(f'model/summary-100k/type_of_charts-{chunk}.html')
